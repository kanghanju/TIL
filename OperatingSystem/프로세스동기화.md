## 프로세스 동기화 
#### 공부 날짜: 2024/06/28

<br><br>
### 키워드
- 동기화
- 수행시기
- 상호 배제,진행,유한 대기 
- 임계 구역(critical section)
- 레이스 컨디션(race condition)
- 뮤텍스락
- 세마포어
- 모니터 

<br>


### 동기화란 
> 프로세스 동기화란 프로세스들 사이의 **수행 시기를 맞춰** 공유데이터의 **일관성을 유지**하는 것. 

수행시기를 맞추는 것이란 
1. 프로세스 **실행 순서** 제어: 프로세스를 올바른 순서대로 제어
2. **상호 배제**: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기


<br>

### race condition(경쟁 상태)
> 여러 프로세스가 동시 다발적으로 **임계 구역**의 코드를 실행해 문제가 발생하는 경우 


### 임계 구역(critical section) 
> 임계 구역이란 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 말한다. 

<br>

OS는 2개 이상의 프로세스가 임계 구역에 **동시에 접근하지 못하도록** 관리를 한다. 이런 임계 구역 문제를 아래 3가지 원칙 하에 해결한다. 
1. mutual exclusion(상호 배제) : 한번에 하나의 프로세스/스레드가 critical section에서 실행할 수 있다.
2. progress(진행) : 아무도 critical section에 없을때 들어가고자 하는 프로세스가 있으면 그 프로세스는 critical section에 들어갈 수 있어야 한다. 
3. bounded waiting(유한 대기) : 하나의 프로세스/스레드가 critical section에 들어가기 위해서 무한정 대기해서는 안된다. 그 프로세스는 언젠가는 임계 구역에 들어갈 수 있어야함. 

<br>

🤔 언제 race condition이 발생할까? 
1. kernel 수행 중에 interrupt 발생할때 
2. process가 system call을해서 user mode에서 kernel mode로 작업 수행 중인데 context switch가 일어나는 경우
3. 멀티프로세서 환경에서 여러 프로세스서가 동시에 공유 메모리 내의 데이터에 접근할 때 


---

<br>

어떻게 해야 임계 구역에 오직 하나의 프로세스만 진입하게 할까? 

어떻게 프로세스의 올바른 실행 순서를 보장하고 동기화를 이루어지게 할까?

<br>

### 뮤텍스 락(Mutex lock)
> 동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 만드는 도구, 즉 **상호 배제를 위한 동기화 도구** 

```java
acquire() {
    while (lock == true) /*만약 임계 구역이 잠겨 있다면*/
        ;                  /*잠겨 있는지 반복적으로 확인*/
    lock = true;/*만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금 */
}

release() {
    lock = false; /*임계 구역 작업이 끝났으면 lock 해제*/
}

```

<br>

### 세마포어(semaphore)
> 뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구. 즉 공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구다. 

#### 세마포어 P,V 연산
- P: 임계 구역 들어가기 전에 수행 
- V: 임계 구역에서 나올 때 수행 

```java
P(S); //S는 임계 구역에 진입할 수 있는 프로세스 개수 or 사용 가능한 공유 자원의 개수 

// 임계 구역

V(S);
```
```java
P(S) {
    while(S <= 0) //만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면
        ; //사용할 수 있는 자원이 있는지 반복적으로 확인하고, 
    S--; //임계 구역에 진입할 수 있는 프로세스가 1개 이상이면 S를 감소시키고 임계 구역에 진입한다.
}

V(S) {
    S++; //임계 구역에서 작업을 마친 뒤 S를 1 증가 시킨다. 
}
```

<br>

🤔 그런데 사용할 수 있는 공유자원이 없는 경우 뮤텍스락도 그렇고 세마포어도 계속해서 사용할 수 있는 자원을 확인해야 한다. 이는 CPU 낭비가 아닐까?

A. 실제로 세마포는 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 **대기 상태**로 만들고, 그 프로세스의 PCB를 **세마포를 위한 대기 큐**에 넣는다. 그리고 임계 구역에서 작업이 끝난 프로세스가 신호를 주면 대기 중인 프로세스를 대기 큐에서 제거하고 , 프로세스 상태를 **준비 상태**로 바꿔준 후에 준비 큐로 옮겨준다. 

```java
P(S) {
    S--;
    if(S < 0) {
        add this process to Queue;
        sleep(); //대기상태 
    }
}

V(S) {
    S++;
    if(S <= 0) {
        remove a process p from Queue; 
        wakeup(p); //프로세스 p를 대기상태에서 준비상태로 만든다. 
    }
}
```

<br>

### 모니터 
세마포는 임계 구역 앞뒤로 일일이 wait(P)와 signal(V) 함수를 명시해야해서 번거롭다. 이를 위해 등장한 동기화 도구가 **모니터**
> 모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스를 묶어서 관리한다. 그리고 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근하도록 하는 동기화 방법이다. 


- 모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 **순서대로 하나씩** 공유자원을 이용하도록 한다. 

- **조건 변수**를 사용해 특정 조건이 만족될 때까지 스레드가 기다리게 하고, 조건이 만족되면 대기중인 스레드를 깨워 작업을 재개할 수 있다. 이를 통해 효율적인 동기화 가능. (실행 순서 제어) 


<br><br>

🤔 그래서 어떤상황에 어떤 동기화 도구를 사용해야하는걸까?.. 아직 잘 모르겠다 

A. 추후에.. 


<br><br>

#### 참고 자료
[자료 1](https://github.com/devSquad-study/2023-CS-Study/blob/main/OS/os_process_synchronization.md)

[자료 2](https://gyoogle.dev/blog/computer-science/operating-system/Semaphore%20&%20Mutex.html)