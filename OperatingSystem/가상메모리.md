## 가상 메모리
#### 공부 날짜: 2024/07/01

<br><br>
### 키워드
- 스와핑
- 스왑 영역, 스왑 아웃, 스왑 인
- 연속적 할당 3가지 방법(최초,최적,최악)
- 외부 단편화 
- 가상메모리
- 페이징
- 페이지
- 프레임
- 페이지 테이블
- 유효비트,참조비트,수정비트,보호비트
- TLB(Translation Lookaside Buffer)
- 내부 단편화 
- 요구 페이징 
- 대표적인 페이지 교체 알고리즘(LRU,최적,FIFO)
- 스레싱 

<br> 


### 스와핑이란?
메모리에 적재된 프로세스 중에는 입출력 작업의 요구로 대기 상태가 되어서 '현재 실행되지 않는 프로세스'가 있을 수 있다. 

> 오랫동안 사용되지 않은 프로세스들을 **임시로 보조기억장치 일부 영역**으로 쫓아내고, 그렇게 해서 생긴 메로리상의 빈 공간에 또 다른 프로세스를 적재해 실행하는 방식 

<br>
이때 프로세스들이 쫒겨나는 보조기억장치의 일부 영역을 **스왑 영역**이라고 한다. 

그리고 **현재 실행되지 않는 프로세스**가 메모리 -> 스왑 영역으로 옮겨지는 것을 **스왑 아웃**이라고 하며, 반대로 스왑 영역 -> 메모리로 옮겨오는 것을 **스왑 인**이라고 한다. 

스왑 아웃 되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃 되기 전의 물리주소와 다른 주소에 적재될 수 있음 ! 


🗨️ 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 크기 > 실제 메모리 크기인 경우에도 <u>프로세스들을 동시 실행할 수 있다.</u> 


<br>

### 메모리 할당 
비어 있는 메모리 공간에 프로세스를 **연속적으로 할당하는 방식**은 대표적으로 3가지가 있다. 

1. 최초 적합 
   1. 운영체제가 메모리 내 빈 공간을 **순서대로 검색**하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식. 
   2. 검색을 최소화해서 **프로세스 빠른 할당**이 가능하다 ! 
2. 최적 적합
   1. 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치한다. 
3. 최악 적합
   1. 운영체제가 빈 공간을 모두 검색해보고 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다. 


하지만 이렇게 프로세스를 메모리에 연속적으로 배치하는 것은 메모리를 효율적으로 사용하는게 아님.**외부 단편화** 문제를 내포하고 있기 때문. 

<br>

### 외부 단편화(external fragmentation)
프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이에 빈 공간들이 생긴다. 
> 메모리에 빈 공간이 있지만 그 공간보다 큰 프로세스를 적재하기 어려워 **메모리 낭비를 초래하는 현상** . 
> 
> 즉 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상이다. 

<br>

- 외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 **압축**하는 방법이 있다. 압축은 여기저기 흩어져 있는 **빈 공간을 하나로 모으는 방식**이다. 
  + 하지만 작은 빈 공간을 하나로 만드는 동안 **시스템은 하던일을 중지**해야 하고
  + 메모리에 있는 내용을 옮기는 작업은 **많은 오버헤드를 야기**한다. 
  + 또한 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어렵다. 

➡️ 이에 외부 단편화를 없앨 수 있는 또 다른 해결방법이 등장했는데 이게 **가상 메모리 기법**, **페이징 기법**이다. 


<br><br>

### 가상 메모리(virtual memory) 
> 실행하고자 하는 프로그램을 **일부만 메모리에 적재**하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.

이를 가능케 하는 가상 메모리 관리 기법은 크게 다음과 같다. 
1. 페이징(현재 대부분 운영체제가 사용하는 페이징 기법)
2. 세그멘테이션

<br>

### 페이징 
> 메모리의 물리 주소 공간을 **프레임**단위로 자르고, 프로세스의 논리 주소 공간을 **페이지** 단위로 자른 뒤 **각 페이지를 프레임에 할당**하는 가상 메모리 관리 기법이다. 

- 페이지 아웃: 페이징 시스템에서 페이지 단위로 스왑 아웃되는 것. 
- 페이지 인: 페이징 시스템에서의 스왑 인 

🔔이는 즉, 한 프로세스 실행을 위해 프로세스 전체가 메모리에 적재될 필요가 없다는 뜻이다.

- 프로세스를 이루는 페이지 중 **실행에 필요한 일부 페이지만**을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둔다. 


<br>

### 페이지 테이블
🤔프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU입장에서 어떻게 순차적으로 실행할 수 있지?? 프로세스가 메모리에 불연속적으로 배치되면 CPU입장에서 '다음에 실행할 명령어 위치'를 찾기가 어렵다.

이를 해결하기 위해 페이징 시스템은 프로세스가 비록 (실제 메모리 주소인) 물리 주소에 불연속적 배치되더라도 
> CPU가 바라보는 주소인 논리 주소에는 페이지가 연속적으로 배치되도록 페이지 테이블을 활용한다. 
>
> 페이지 테이블은 페이지 번호 - 프레임 번호를 짝지어 주는 일종의 이정표다. 페이지 번호를 이용해 **페이지가 적재된 프레임**을 찾을 수 있다 ! 

<br>

페이지 테이블의 각각의 행들은 **페이지 테이블 엔트리**라고 한다.
여기에는 (페이지 번호,프레임 번호) 말고도 **유효 비트,보호 비트,참조 비트,수정 비트**등이 있다. 
1. 유효 비트(valid bit): 현재 해당 페이지에 접근 가능한지 여부를 알려준다. 즉 페이지가 메모리에 적재되어 있는지, 보조기억장치에 있는지 알려주는 비트다. 
    + 만일 CPU가 유효 비트가 0인(보조기억장치에 있는) 페이지에 접근하려고 하면 **페이지 폴트(page fault) 예외가 발생**한다. 
2. 보호 비트(protection bit): 페이지 보호 기능을 위해 존재하는 비트. 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지 인지, 읽기만 가능한 페이지인지 나타낼 수 있다. 
3. 참조 비트(reference bit): CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다. 
4. 수정 비트(modified bit): 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다. 수정 비트는 페이지가 메모리에서 사라질 때 보조기억 장치에 쓰기 작업을 해야하는지, 할필요가 없는지 판단하기 위해 사용한다. 


<br>

### 내부 단편화(internal fragmentation)
페이징은 외부 단편화 문제를 해결하지만 내부 단편화를 야기할 수 있다. 
> 페이지 크기보다 프로세스 크기가 작아 메모리를 낭비하는 현상 

🤔 그러면 페이지 크기를 작게 설정하면 되지 않나?

A. 내부 단편화의 크기는 작아질 수 있겠지만, 그만큼 페이지 테이블의 크기가 커져 페이지 테이블이 차지하는 공간이 낭비된다. 

<br> 
<br>

### 요구 페이징 
> **실행에 요구되는 페이지만 적재**하는 페이징 기법. 사용되지 않는 페이지는 스왑 공간에 저장되며 메모리의 공간 절약 가능. 


요구 페이징 시스템이 안정적으로 작동하려면 다음 두 가지를 해결해야 한다. 
1. 페이지 교체
   + 당장 실행에 필요한 페이지를 메모리에 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다. 
   + <u>어떤 페이지를 보조기억장치로 내보낼지 결정하는 방법</u>을 **페이지 교체 알고리즘**이라고 한다. 
2. 프레임 할당


<br>

### 페이지 교체 알고리즘 
좋은 페이지 교체 알고리즘이란 일반적으로 **페이지 폴트**를 가장 적게 일으키는 알고리즘이다. 

대표적인 페이지 교체 알고리즘 

1. FIFO 페이지 교체 알고리즘(First In First Out Page Replacement)
    + 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식이다. 
    + 아이디어와 구현이 간단하다. 
    + 자주 참조되는 페이지가 먼저 적재되었다는 이유만으로 내쫓길 수 있다는 문제가 있다. 
2. 최적 페이지 교체 알고리즘(Optimal Page Replacement)
    + CPU에 의해 **참조된 횟수**를 고려하는 페이지 교체 알고리즘 
    + 가장 낮은 페이지 폴트율을 보장하는 알고리즘이다. 
    + 실제 구현이 어렵다. 
    + **앞으로 오랫동안 사용되지 않을 페이지**를 내보낸다... 하지만 이를 예측하기란 어렵다. 
    + 운영체제에서 사용하기보다는, 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 쓰인다. 
3. LRU 페이지 교체 알고리즘(Least Recently Used Page Replacement)
   + **가장 오랫동안 사용되지 않은** 페이지를 교체하는 알고리즘이다. 
   + 최근에 사용되지 않은 페이지는 앞으로도 사용하지 않을 것이라는 아이디어를 토대로 만들었다. 


<br>

### 스레싱과 프레임 할당(thrashing) 
나쁜 페이지 교체 알고리즘에 따라 페이지 폴트가 자주 발생할 수도 있지만, 프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생한다. 
> 스레싱이란 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요해 성능이 저해되는 문제다. 

+ 동시에 실행되는 프로세스의 수를 늘린다고 해서 CPU이용률이 그에 비례해서 증가하는게 아니다.  필요 이상으로 멀티프로그래밍의 정도를 늘리면 각 프로세스들이 이용할 수 있는 프레임 수가 적어져 **페이지 폴트**가 지나치게 발생해 CPU이용률이 떨어진다. 

따라서 운영체제는 각 프로세스들이 무리 없이 실행되기 위해 **최소한의 프레임 수를 파악**하고 프로세스들에 적절한 수만큼 프레임을 할당해줄 수 있어야 한다. 


<br><br>

#### 참고 자료
혼자서 공부하는 컴퓨터구조와 운영체제 